 챕터-1 리액트 컴포넌트 생성 및 DOM에 렌더링
  - JSX 개념 잡음. jsx => vanilla js => class(React Element) 리턴
  - 클래스 를 인스턴스화 한 후 타켓 DOM 에 렌더링  컴포넌트 구조

  *컴포넌트 구조화
   앱은 컴포넌트들의 모음이다.
    앱 구조
    - index.js
        - search_bar.js
        - video_detail.js
        - video_item.js
        - video_list.js

    *규칙!
       - 파일 1개당 한개의 컴포넌트!

    *컴포넌트
       - 함수 기반 컴포넌트: simple just return jsx and without state
       - 클래스 기반 컴포넌트: return jsx and other do!  (추가 기능)
         ex) event handle, 컴포넌트 상호작용, 상태


    *클래스 컴포넌트 이벤트 핸들링
      - 인라인 방식
        <input onChange={(e) => e.target.value} />
      - 핸들러 방식
        <input onChange={this.onInputChange} />
        => 메서드 이름 짓기 : [on OR handle] + [element 명] + [event type]

    *상태(state)
        state is plain js Object
        each class component has a individual state object
        즉 컴포넌트의 스테이트는 지역적인 스테이트 이다.
        각 컴포넌트 마다 개별적으로 스테이트를 가지고 있음. 나중에 전역 스테이트로 "리덕스"를 쓸 예정이다.
        스테이트 객체는 클래스의 생성자에서 초기화 함
        state 객체의 값이 변경하면 render() 메서드가 호출되여 리렌더링 된다. => DOM 에 푸시한다.
        state 객체는 상태는 setState() 메서드로 변경해야 한다. (생성자 제외)

        <컴포넌트 이벤트 핸들링>
         클래스 컴포넌트일 경우 자신의 스테이트를 가지고 있고 스테이트에 값등을 저장한다.
            <input
                value={this.state.term}
                onChange={(event) => this.setState({term: event.target.value})} />

         중요 포인트는 이벤트가 발생하고 입력 값을 인풋이 아니라 컴포넌트 스테이트 상태로 저장시킨다.
         인풋의 값을 보여줄때도 인풋의 자체 값이 아니라 스테이트 저장된 상태 값을 인풋으로 내려 보낸다.


    *컴포넌트 렌더링 방식: render()
        부모 컴포넌트 리렌더링 => 그 부모의 자식 컴포넌트도 리렌더링 => 자식의 자식 컴포넌트도 리랜더링...



    챕터-2 : 유투브 검색 구현하기
    질문: 어디서 api 통신을 하여 데이터를 가져오고 어떤 컴포넌들이 이 데이터를 사용하는가?
     리액트는 "하향 데이터 플로우" 방식으로 "상위 컴포넌트"가 데이터를 가져올 권리를 가져야 한다.
     상위 컴포넌트에서 하위 컴포넌트들 에게 데이터를 전달한다.  상위 ==> 하위
     데이터는 배열, 이거나 객체, 그리고 중요한 '함수'를 전달한다.
     함수는 대부분 부모 컴포넌트의 스테이트의 상태를 변형 하는 함수 이다. ex) (selectedVideo) => this.setState({selectedVideo})
     *이렇게 하는 이유
        1. 이벤트가 하위 컴포넌트에서 발생 하지만 리액트는 하향 테이터 플로우 이므로 하위에서 상위 컴포넌트로 요청 하지 않는다.
           대신 상위 컴포넌트의 스테이를 변경할 수 있는 (콜백)함수를 전달 한다.
           하위 컴포넌트에서 이벤트 발생시 상위 컴포넌트에서 준 (콜백)함수를 이벤트 핸들러로 쓴다.

        2. 상위 컴포넌트의 스테이트가 변경되면 render() 메서드가 리렌더링 되므로 화면이 새로 고침 된다.

        3. 리액트는 데이터 기반으로 화면이 새로고침 되는 특징을 가지고 있다.


    *CSS 스타일링
     1. src/style/style.css 에 스타일을 정의 한다.
     2. 컴포넌트 이름과 css 클래스 이름을 맞춘다. (팁)
     x) SearchBar 컴포넌트의 class 는 .search-bar 로 한다.


    &검색 주기 제어 (lodash debounce 함수!!!! 였군)
       - 솔루션에서는 검색 주기 제어를 SearchBar 컴포넌트에서 하지 않고 상위 index.js 에서 한다..
       - 음.. SearchBar컴포넌트에서 해야 한다고 생각함
